$o-table-brand: null !default;
$_o-table-brands: () !default;
$_o-table-current-variant: ();
$_o-table-current-depth: 0;
$_o-table-default-brand: 'masterbrand';
$_o-table-default-brand-is-configured: false !default;

/**
* Define configuration for a brand.
*
* @access public
* @param {string} $brand
* @param {map} $config
**/
@mixin oBrandDefine($brand, $config) {
    // Validate config.
    @if type-of($config) != 'map' {
        @error 'Could not set brand "#{$brand}", it\'s configuration must be a map.';
    }
    // Indicate the default brand is configured.
    // This is a must by all components before using o-brand.
    @if $_o-table-default-brand == $brand {
        $_o-table-default-brand-is-configured: true !global;
    }
    // Validate brand variables and settings.
    $variables: map-get($config, 'variables');
    $settings: map-get($config, 'settings');
    $errorMessage: 'Could not set brand "#{$brand}".';
    @if $variables and (type-of($variables) != 'map' and type-of($variables) != 'list' ) {
        @error $errorMessage + ' Config key "variables" should be a map but is of type #{type-of($variables)}.';
    }
    @if $settings and (type-of($settings) != 'map' and type-of($settings) != 'list' ) {
        @error $errorMessage + ' Config key "settings" should be a map but is of type #{type-of($settings)}.';
    }
    // Sort and merge variant config.
    // In brand variables maps are considered variant config, where the key is the variant.
    // Brand variants could be defined twice e.g. ('a', 'b', 'c'): (background: red), ('c', 'a', 'b'): (background: red).
    $sorted-variables: ();
    @each $key, $value in $variables {
        // Sort brand variant key.
        @if type-of($value) == 'map' {
            $key: _oBrandQuickSort($key);
        }
        // Merge variable/variant map.
        $sorted-variables: map-merge($sorted-variables, ($key: $value));
    }
    // Add brand config to defined component brands.
    $_o-table-brands: map-merge($_o-table-brands, ($brand: (
        'variables': $sorted-variables,
        'settings': $settings
    ))) !global;
}

/**
* Gets a variable for the current brand and configured for variant.
* If multiple variables are requested they are concatenated for use as one property.
*
* @example
*     @oBrandGet('example-border-size', 'example-border-style', 'example-border-color'); // 1px solid red
*     @oBrandGet('inverse-stripe-color'); // black
*
* @access public
* @param {arglist} $variables
* @return {string | number | color | null}
**/
@function oBrandGet($variables...) {
    // For one variable return value.
    @if length($variables) == 1 {
        @return _oBrandGetVariableValue(nth($variables, 1));
    }
    // Concatenate multiple requested variables for use in one property.
    $values: ();
    @each $variable in $variables {
        @if $variable {
            $values: join($values,  _oBrandGetVariableValue($variable));
        }
    }
    @return $values;
}

/**
* Configures a content block for a brand variant.
* A single variant (string) or compound variant (list) is accepted.
* This mixin may also be nested to target compound variants.
* The content block will only be output in the brand supports the variant.
* Calls for brand variables within will return the value for the configured variant.
*
* @example
*     _oBrandConfigureFor('inverse') {
*        // Will use configuration for the 'inverse' variant when getting variable values.
*        // This will not be output if the brand does not support the "inverse" variant.
*       _oBrandConfigureFor('b2b') {
*            // Will use configuration for the compound variant 'inverse,b2b' when fetching variable values.
*       }
*     }
*
* @example
*     _oBrandConfigureFor(('inverse', 'b2b')) {
*        // Will use configuration for the compound variant 'inverse,b2b' when fetching variable values.
*     }
*
* @access public
* @param {string | list} $variant
**/
@mixin oBrandConfigureFor($variant) {
    // Validate variant.
    @if type-of($variant) != 'list' and type-of($variant) != 'string' {
        @error 'Cound not configure for variant #{type-of($variant)} "#{$variant}", expecting a list or string.';
    }
    // Add to current variant to output variant content.
    @include _oBrandAddToCurrentVariant($variant);
    @if _oBrandSupports($variant) { // @todo should this variant check be against the whole current variant?
        @content;
    }
    // Variant content output. Remove from the current variant so future CSS is not effected.
    @include _oBrandRemoveFromCurrentVariant($variant);
}

/**
* Check the brand's configured settings to see if it supports a variant.
* Using this function and a conditional may make sense if there is no variant specific configuration.
* However `oBrandConfigureFor` should be used instead where possible.
* Doing so will support variant specific configuration in the future without code changes.
*
* @see oBrandConfigureFor
* @access private
* @param {string | list} $variant
* @return {boolean}
**/
@function _oBrandSupports($variant) {
    // Validate variant.
    @if type-of($variant) != 'list' and type-of($variant) != 'string' {
        @error 'Cound not check support for variant #{type-of($variant)} "#{$variant}", expecting a list or string.';
    }
    // Get all brand settings, which are used to indicate variant support.
    $brand-config: _oBrandGetConfig($o-table-brand);
    $brand-settings: map-get($brand-config, 'settings');
    // No settings are enabled so no variants are supported.
    @if type-of($brand-settings) != 'map' {
        @return false;
    }
    // Check for a setting name which matches the variant.
    // Each part of a compound variant should be specified with its own setting.
    // E.g. Variant ('stripe', 'compact') is enabled with both 'stripe' and 'compact' settings set to true.
    @each $variant-part in $variant {
        $setting-defined: type-of($brand-settings) == 'map' and map-has-key($brand-settings, $variant-part);
        @if $setting-defined == false or map-get($brand-settings, $variant-part) == false {
            @return false;
        }
    }
    @return true;
}

/**
* Gets a variable for the current brand and variant.
*
* @access private
* @param {string} $variable
* @return {string | number | color | null}
**/
@function _oBrandGetVariableValue($variable) {
    // Get all brand variables.
    $brand-config: _oBrandGetConfig($o-table-brand);
    $variables: map-get($brand-config, 'variables');
    // Use variant variables if a variant is configured.
    @if length($_o-table-current-variant) > 0 {
        $variables: map-get($variables, _oBrandQuickSort($_o-table-current-variant));
    }
    // Variables for the current brand and variant found.
    @if type-of($variables) == 'map' {
        // Check the requested variable is defined.
        @if map-has-key($variables, $variable) == false {
            @warn 'The "#{$variable}" variable is not defined for the ' + if(length($_o-table-current-variant) > 0, 'variant "#{$_o-table-current-variant}" of ', '') + 'the "#{$o-table-brand}" brand.';
            @return null;
        }
        // Get the defined value and validate it can be used as a CSS property.
        // Boolean variant and feature toggles are configured seperately.
        $value: map-get($variables, $variable);
        $supported-variable-types: ('string', 'number', 'color', 'list', 'null');
        @if not index($supported-variable-types, type-of($value)) {
            @error 'Brand variable "#{$variable}" is type of "#{type-of($value)}" but can only be one of: #{$supported-variable-types}.';
        }
        @return $value;
    }
    // Warn but do not error if a variable is not defined for the current brand and variant.
    // A CSS property with SASS value `null`  will not be output.
    @warn 'Variables are not set for ' + if(length($_o-table-current-variant) > 0, 'the variant "#{$_o-table-current-variant}" of ', '') + 'the "#{$o-table-brand}" brand.';
    @return null;
}

/**
* Update the current variant to with a new variant.
* If a variant is already set they are compounded.
*
* @access private
* @param {string | list} $variant
**/
@mixin _oBrandAddToCurrentVariant($variant) {
    @if $_o-table-current-depth == 0 {
        $_o-table-current-variant: if(type-of($variant) == 'list', $variant, ($variant)) !global;
    } @else {
        $_o-table-current-variant: join($_o-table-current-variant, $variant, 'comma') !global;
    }
    $_o-table-current-depth: $_o-table-current-depth + length($variant) !global;
}

/**
* Update the current variant by removing a variant.
*
* @access private
* @param {string | list} $variant
**/
@mixin _oBrandRemoveFromCurrentVariant($variant) {
    $_o-table-current-depth: $_o-table-current-depth - length($variant) !global;
    @if $_o-table-current-depth == 0 {
        $_o-table-current-variant: () !global;
    }
    $new-variants: ();
    $num: 1;
    @while $num <= $_o-table-current-depth {
        $new-variants: join($new-variants, (nth($_o-table-current-variant, $num)), 'comma');
        $num: $num + 1;
    }
    $_o-table-current-variant: if(length($new-variants) == 0, (), $new-variants) !global;
}

/**
* Get all config for a given brand.
*
* @access private
* @param {string} $brand
* @return {map}
**/
@function _oBrandGetConfig($brand) {
    // Get config for the brand.
    $brand-config: map-get($_o-table-brands, $brand);
    // Validate the default brand is configured. Otherwise using o-brand is not allowed.
    // The default brand must be configured by the component as it is the fallback.
    @if $_o-table-default-brand-is-configured == false {
        @error 'The default brand "#{$_o-table-default-brand}" must be set.';
    }
    // Validate the requested brand is configured, fallback to the default brand otherwise.
    @if $brand-config == null {
        @warn 'The requested brand "#{$brand}" has not been set. Using "#{$_o-table-default-brand}" brand instead.';
        @return _oBrandGetConfig($_o-table-default-brand);
    }
    @return $brand-config;
}

/**
* Quick sort alphanumeric list.
*
* @access private
* @param {list} $list The list to sort.
* @return {list}
**/
@function _oBrandQuickSort($list) {
    // sass-lint:disable variable-name-format
    $less: ();
    $equal: ();
    $large: ();
    @if length($list) > 1 {
        $seed: nth($list, ceil(length($list) / 2));
        @each $item in $list {
            @if $item == $seed {
                $equal: append($equal, $item);
            } @else if _oBrandStringCompare($item, $seed) {
                $less: append($less, $item);
            } @else if not _oBrandStringCompare($item, $seed) {
                $large: append($large, $item);
            }
        }
        @return join(join(_oBrandQuickSort($less), $equal), _oBrandQuickSort($large), list-separator($list));
    }
    @return $list;
    // sass-lint:enable variable-name-format
}

/**
* Compares two strings to determine which comes first.
* Sort order defined in an alphanumeric list.
*
* @access private
* @param {string} $string-a
* @param {string} $string-b
* @return {list}
**/
@function _oBrandStringCompare($string-a, $string-b) {
    // sass-lint:disable variable-name-format
    $character-order: ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z');
    @if type-of($string-a) == 'number' and type-of($string-b) == 'number' {
        @return $string-a < $string-b;
    }

    $string-a: to-lower-case($string-a + unquote(''));
    $string-b: to-lower-case($string-b + unquote(''));

    @for $i from 1 through min(str-length($string-a), str-length($string-b)) {
        $character-a: str-slice($string-a, $i, $i);
        $character-b: str-slice($string-b, $i, $i);

        @if $character-a and $character-b and index($character-order, $character-a) != index($character-order, $character-b) {
            @return index($character-order, $character-a) < index($character-order, $character-b);
        }
    }

    @return str-length($string-a) < str-length($string-b);
    // sass-lint:enable variable-name-format
}
