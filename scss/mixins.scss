$o-brand: null !default; // The chosen current brand.
$o-brand-debug-mode: false !default; // Show extra (optional) warnings. E.g. value for variant not found.
$_o-brand-default: 'master'; // The fallback current brand. Allows us to check if o-brand is set explicitly.
$_o-brands: () !default; // A map of components to their defined brands.
$_o-brand-default-not-set-warning: false !default; // Has the default not set warning been output.

/// Define component configuration for a brand.
///
/// @access public
/// @param {string} $component
/// @param {string} $brand
/// @param {map} $config
@mixin oBrandDefine($component, $brand, $config) {
    @if type-of($component) != 'string' or $component == '' {
        @error 'Could not set brand "#{$brand}" for component "#{$component}". A component name of type string must be given.';
    }
    @if type-of($brand) != 'string' or $brand == '' {
        @error 'Could not set brand "#{$brand}" for component "#{$component}". A brand of type string must be given.';
    }
    // Define brand configuration.
    @if not _oBrandIsDefined($component, $brand) {
        $result: _oBrandUpdateConfig($component, $brand, $config);
    }
}

/// Gets the value of a component variable for the current brand.
/// If multiple variables are requested they are concatenated.
///
/// @example scss
///     @oBrandGet($component: 'o-component', $variables: ('example-border-size', 'example-border-style', 'example-border-color')); // 1px solid red
/// @example scss
///     @oBrandGet($component: 'o-component', $variables: 'example-color'); // black
/// @example scss
///     @oBrandGet($component: 'o-component', $variables: 'example-color', $from: 'inverse'); // white
/// @example scss
///     @oBrandGet($component: 'o-component', $variables: 'example-color', $from: (example-color: yellow)); // yellow
///
/// @access public
/// @param {string} $component
/// @param {string | list} $variables
/// @param {map|string} $from Get variable values from a defined brand variant or from a map of variables.
/// @return {string | number | color | bool | null}
@function oBrandGet($component, $variables, $from: null) {
    // Validate variant.
    @if type-of($from) != 'string' and type-of($from) != 'map' and type-of($from) != 'null' {
        @error 'Cound not check support for variant "#{$from}", expecting a string, map, or null but found "#{type-of($from)}".';
    }
    // If from default component variables or a pre-defined variant.
    @if type-of($from) == 'string' or type-of($from) == 'null' {
        $brand-config: _oBrandGetConfig($component, $o-brand);
        $brand-variables: map-get($brand-config, 'variables');
        @if type-of($from) == 'null' {
            // Get from default variables.
            $from: $brand-variables;
        } @else if type-of($from) == 'string' {
            // Get from variant variables.
            $from: map-get($brand-variables, $from);
        }
    }

    // No variable values defined.
    @if type-of($from) != 'map' {
        @return null;
    }

    // Get and concatenate requested variable values.
    $values: null;
    @each $variable in $variables {
        $value: map-get($from, $variable);
        @if type-of($value) == 'map' {
            @error 'Could not get variable "#{$variable}" for component "#{component}" as it is a map of variant variables.';
        }
        @if $values {
            $values: join($values, $value);
        } @else {
            $values: $value;
        }
    }

    @return $values;
}


/// Updates config for a given component and brand using a recursive merge.
///
/// @access private
/// @param {string} $component
/// @param {string} $brand
/// @param {map} $config
/// @return {map}
@function _oBrandUpdateConfig($component, $brand, $config) {
    // Validate config
    $valid: _oBrandValidateConfig($component, $brand, $config);
    // Update config.
    $_o-brands: _oBrandRecursiveMapMerge($_o-brands, ($component: ($brand: $config))) !global;
    @return $_o-brands;
}

/// Validate config.
///
/// @access private
/// @param {string} $component
/// @param {string} $brand
/// @param {map} $config
/// @return {map}
@function _oBrandValidateConfig($component, $brand, $config) {
    $errorMessage: '"#{$component}" configuration for brand "#{$brand}" is invalid';
    @if type-of($config) != 'map' {
        @error '#{$errorMessage}. Its configuration must be a map.';
    }
    // Validate brand variables and supported variants.
    $variables: map-get($config, 'variables');
    $supports-variants: map-get($config, 'supports-variants');
    @if $variables and (type-of($variables) != 'map' and type-of($variables) != 'list' ) {
        @error '#{$errorMessage}. Config key "variables" should be a map but is of type #{type-of($variables)}.';
    }
    @if $supports-variants and (type-of($supports-variants) != 'map' and type-of($supports-variants) != 'list' ) {
        @error '#{$errorMessage}. Config key "#{$supports-variants}" should be a map but is of type #{type-of($supports-variants)}.';
    }
    @return true;
}

/// Check the brand is configured.
/// By default checks the default brand is configured.
/// The default brand must be configured by the component as it is the fallback.
///
/// @access private
/// @param {string} $component
/// @param {string} $brand
/// @return {boolean}
@function _oBrandIsDefined($component, $brand: $_o-brand-default) {
    $component-brands: map-get($_o-brands, $component);
    $component-brands: if(type-of($component-brands) == 'map', $component-brands, ());
    @return type-of(map-get($component-brands, $brand)) == 'map';
}

/// Check if the brand supports a variant.
///
/// @access public
/// @param {string} $component
/// @param {string} $variant
/// @return {boolean}
@function oBrandSupportsVariant($component, $variant) {
    // A custom or null variant is always supported.
    @if type-of($variant) == 'map' and type-of($variant) == 'null' {
        @return true;
    }
    // Check support for a pre-defined variant.
    @if type-of($variant) != 'string' {
        @error 'Cound not check support for variant "#{$variant}", expecting a string, map, or null but found "#{type-of($variant)}".';
    }
    // Get supported variants.
    $brand: if($o-brand, $o-brand, $_o-brand-default);
    $brand-config: _oBrandGetConfig($component, $o-brand);
    $supports-variants: map-get($brand-config, 'supports-variants');
    // No variants are supported.
    @if type-of($supports-variants) != 'map' {
        @return false;
    }
    // Check if variant is supported.
    @return if(map-get($supports-variants, $variant), true, false);
}

/// Get all config for a given component and brand.
///
/// @access private
/// @param {string} $component
/// @param {string} $brand
/// @return {map}
@function _oBrandGetConfig($component, $brand) {
    // Get config for the brand.
    $component-brands: map-get($_o-brands, $component);
    $component-brands: if(type-of($component-brands) == 'map', $component-brands, ());
    $brand-config: map-get($component-brands, $brand);
    // The default brand must be configured before o-brand can be used.
    @if not _oBrandIsDefined($component) {
        @error 'The default brand "#{$_o-brand-default}" must be defined for "#{$component}" before using o-brand.';
    }
    // Validate the requested brand is configured, fallback to the default brand otherwise.
    @if $brand-config == null {
        @if not $_o-brand-default-not-set-warning and $o-brand-debug-mode == true {
            $_o-brand-default-not-set-warning: true !global;
            @warn 'The requested brand "#{$brand}" has not been set. Using "#{$_o-brand-default}" brand instead.';
        }
        @return _oBrandGetConfig($component, $_o-brand-default);
    }
    @return $brand-config;
}


/// Ensure variants are expressed consistently,
/// so they may be compared and matched.
///
/// Only effects compound variants:
/// - Makes a variant list alphabetical.
/// - Makes a variant list have a comma list separator.
///
/// @access private
/// @param {list|string} $variant The variant to normalise.
/// @return {list|string}
@function _oBrandNormaliseVariant($variant) {
    @if type-of($variant) != 'list' {
        @return $variant;
    }
    // Compound variant is expressed in order.
    $variant: _oBrandQuickSort($variant);
    // List separator is consistent.
    $variant: join($variant, (), 'comma');
    @return $variant;
}


/// Quick sort alphanumeric list.
///
/// @access private
/// @param {list} $list The list to sort.
/// @return {list}
@function _oBrandQuickSort($list) {
    // sass-lint:disable variable-name-format
    $less: ();
    $equal: ();
    $large: ();
    @if length($list) > 1 {
        $seed: nth($list, ceil(length($list) / 2));
        @each $item in $list {
            @if $item == $seed {
                $equal: append($equal, $item);
            } @else if _oBrandStringCompare($item, $seed) {
                $less: append($less, $item);
            } @else if not _oBrandStringCompare($item, $seed) {
                $large: append($large, $item);
            }
        }
        @return join(join(_oBrandQuickSort($less), $equal), _oBrandQuickSort($large), list-separator($list));
    }
    @return $list;
    // sass-lint:enable variable-name-format
}

/// Compares two strings to determine which comes first.
/// Sort order defined in an alphanumeric list.
///
/// @access private
/// @param {string} $string-a
/// @param {string} $string-b
/// @return {list}
@function _oBrandStringCompare($string-a, $string-b) {
    // sass-lint:disable variable-name-format
    $character-order: ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z');
    @if type-of($string-a) == 'number' and type-of($string-b) == 'number' {
        @return $string-a < $string-b;
    }

    $string-a: to-lower-case($string-a + unquote(''));
    $string-b: to-lower-case($string-b + unquote(''));

    @for $i from 1 through min(str-length($string-a), str-length($string-b)) {
        $character-a: str-slice($string-a, $i, $i);
        $character-b: str-slice($string-b, $i, $i);

        @if $character-a and $character-b and index($character-order, $character-a) != index($character-order, $character-b) {
            @return index($character-order, $character-a) < index($character-order, $character-b);
        }
    }

    @return str-length($string-a) < str-length($string-b);
    // sass-lint:enable variable-name-format
}

/// Merge config maps recursively.
/// Keys in $map2 will take precedence over keys in $map1.
///
/// @acess private
/// @link https://github.com/pentzzsolt/sass-recursive-map-merge/
@function _oBrandRecursiveMapMerge($map1, $map2) {
    @if ((type-of($map1) == map or type-of($map1) == list) and (type-of($map2) == map or type-of($map2) == list)) {
        $result: $map1;
        @each $key, $value in $map2 {
            @if (type-of(map-get($result, $key)) == map and type-of($value) == map) {
                $result: map-merge($result, ($key: _oBrandRecursiveMapMerge(map-get($result, $key), $value)));
            } @else {
                $result: map-merge($result, ($key: $value));
            }
        }
        @return $result;
    } @else {
        @warn '_oBrandRecursiveMapMerge() expects it\'s parameters to be of type "map".';
        @return null;
    }
}
